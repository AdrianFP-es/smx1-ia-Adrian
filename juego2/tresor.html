<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Juego del Tesoro - Niveles</title>
  <style>
    html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:#111;color:#fff;display:flex;align-items:center;justify-content:center}
    .wrap{width:920px;display:flex;flex-direction:column;align-items:center;gap:12px}
    canvas{background:#1f1f1f;border:4px solid #333;display:block}
    .hud{display:flex;gap:18px;font-size:16px;align-items:center}
    .msg{color:#bbb;font-size:13px}
    .overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.7)}
    .box{background:#202020;padding:24px;border-radius:8px;border:2px solid #4a4}
    button{margin-top:10px;padding:8px 12px;border-radius:6px;border:none;background:#4a4;color:#000;cursor:pointer}
    button:hover{opacity:0.9}
  </style>
</head>
<body>
  <div class="wrap">
    <h2>üó∫Ô∏è Busca el Tesoro ‚Äî Niveles</h2>
    <div class="hud">
      <div>Nivel: <b id="level">1</b></div>
      <div>Tesoros: <b id="found">0</b></div>
      <div>Movimientos: <b id="moves">0</b></div>
      <div>Tiempo: <b id="time">0</b>s</div>
    </div>

    <div style="position:relative">
      <canvas id="game" width="800" height="600"></canvas>
      <div id="overlay" class="overlay">
        <div class="box" id="winBox">
          <h3 id="winText">Has ganado!</h3>
          <p id="winStats"></p>
          <button id="restartBtn">Jugar de nuevo (Espacio)</button>
        </div>
      </div>
    </div>

    <div class="msg">Mueve el personaje con las flechas. Encuentra el tesoro para pasar de nivel. Cada nivel tiene un mapa nuevo y mayor dificultad.</div>
  </div>

  <script>
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const overlay = document.getElementById('overlay');
  const winText = document.getElementById('winText');
  const winStats = document.getElementById('winStats');
  const restartBtn = document.getElementById('restartBtn');
  const levelEl = document.getElementById('level');
  const foundEl = document.getElementById('found');
  const movesEl = document.getElementById('moves');
  const timeEl = document.getElementById('time');

  const CANVAS_W = canvas.width;
  const CANVAS_H = canvas.height;

  let level = 1;
  let treasuresFound = 0;
  let moves = 0;
  let startTime = Date.now();
  let gameOver = false;
  const MAX_LEVEL = 6;

  let worldW = CANVAS_W;
  let worldH = CANVAS_H;

  const player = {
    x: 100, y: 100, w: 28, h: 28, speed: 4, color: '#5fb8ff'
  };

  // --- Part√≠culas (confeti) ---
  const particles = [];
  const CONFETTI_COLORS = ['#ff3b3b','#ffd24d','#4ae17a','#6fc3ff','#d78bff','#ff8fa3'];
  function spawnConfetti(wx, wy, n = 40){
    for(let i=0;i<n;i++){
      const angle = Math.PI*2 * Math.random();
      const speed = Math.random()*6 + 2;
      particles.push({
        x: wx + rand(-8,8),
        y: wy + rand(-8,8),
        vx: Math.cos(angle)*speed,
        vy: Math.sin(angle)*speed - Math.random()*4,
        life: Math.random()*900 + 600,
        age: 0,
        size: Math.random()*3 + 2,
        color: CONFETTI_COLORS[Math.floor(Math.random()*CONFETTI_COLORS.length)]
      });
      if(particles.length > 500) particles.shift();
    }
  }

  function updateParticles(dt){
    for(let i = particles.length-1; i>=0; i--){
      const p = particles[i];
      p.vy += 0.12 * dt; // gravedad ligera
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.age += dt * 16.666;
      if(p.age > p.life) particles.splice(i,1);
    }
  }

  function drawParticles(){
    ctx.save();
    for(const p of particles){
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x - 1, p.y - 1, p.size, p.size);
    }
    ctx.restore();
  }

  // --- Sonidos simples con WebAudio (no requiere ficheros externos) ---
  let audioCtx = null;
  function ensureAudio(){
    if(audioCtx) return audioCtx;
    try{ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
    catch(e){ audioCtx = null; }
    return audioCtx;
  }

  function playBeep(freq=440, duration=0.12, type='sine', gain=0.12){
    const ac = ensureAudio();
    if(!ac) return;
    const o = ac.createOscillator();
    const g = ac.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = gain;
    o.connect(g); g.connect(ac.destination);
    o.start();
    const now = ac.currentTime;
    g.gain.setValueAtTime(gain, now);
    g.gain.exponentialRampToValueAtTime(0.001, now + duration);
    o.stop(now + duration + 0.02);
  }

  function playPickup(){
    playBeep(880, 0.14, 'sine', 0.15);
    setTimeout(()=> playBeep(1100, 0.10, 'sine', 0.08), 60);
  }
  function playHit(){
    playBeep(180, 0.08, 'square', 0.12);
  }

  let treasure = { x:0, y:0, w:28, h:28, color:'#ffd24d' };
  let obstacles = [];
  let camX = 0, camY = 0;
  let visibility = 220;
  let collided = false;
  let _lastFrameTime = 0;
  const keys = {};

  function rand(min,max){ return Math.random()*(max-min)+min; }
  function rndInt(a,b){ return Math.floor(rand(a,b+1)); }

  function aabbColl(a,b){
    return !(a.x + a.w <= b.x || a.x >= b.x + b.w || a.y + a.h <= b.y || a.y >= b.y + b.h);
  }

  function spawnMapForLevel(l){
    worldW = Math.min(3000, CANVAS_W * (1 + 0.6*(l-1)));
    worldH = Math.min(3000, CANVAS_H * (1 + 0.5*(l-1)));
    visibility = Math.max(80, 250 - (l-1)*30);
    treasure.w = treasure.h = Math.max(12, 28 - (l-1)*3);
    player.speed = 4 + Math.floor((l-1)/3);

    obstacles = [];
    const baseCount = 6 + (l-1)*6;
    for(let i=0;i<baseCount;i++){
      const ow = rndInt(40, 120 + l*12);
      const oh = rndInt(20, 100 + l*10);
      const ox = rand(0, worldW - ow);
      const oy = rand(0, worldH - oh);
      const ob = { x: ox, y: oy, w: ow, h: oh };
      const playerStart = { x: CANVAS_W/2 - 120, y: CANVAS_H/2 - 120, w:240, h:240 };
      if (aabbColl(ob, playerStart)) continue;
      obstacles.push(ob);
    }

    player.x = Math.max(10, Math.min(worldW- player.w - 10, worldW/2 + rand(-80,80)));
    player.y = Math.max(10, Math.min(worldH- player.h - 10, worldH/2 + rand(-80,80)));
    spawnTreasure();
  }

  function spawnTreasure(){
    const minDist = Math.min(Math.max(120, 150 + (level-1)*60), Math.max(worldW, worldH)*0.7);
    let attempts = 0;
    while(true){
      attempts++;
      const tx = rand(20, worldW - treasure.w - 20);
      const ty = rand(20, worldH - treasure.h - 20);
      const cx = tx + treasure.w/2;
      const cy = ty + treasure.h/2;
      const px = player.x + player.w/2;
      const py = player.y + player.h/2;
      const d = Math.hypot(cx-px, cy-py);
      if(d < minDist) continue;
      const trBox = { x: tx, y: ty, w: treasure.w, h: treasure.h };
      if(obstacles.some(ob => aabbColl(trBox, ob))) continue;
      treasure.x = tx; treasure.y = ty;
      break;
      if(attempts>1000){
        treasure.x = Math.max(20, Math.min(worldW - treasure.w - 20, px + minDist));
        treasure.y = Math.max(20, Math.min(worldH - treasure.h - 20, py + minDist));
        break;
      }
    }
  }

  function updateCamera(){
    camX = Math.max(0, Math.min(worldW - CANVAS_W, player.x - CANVAS_W/2 + player.w/2));
    camY = Math.max(0, Math.min(worldH - CANVAS_H, player.y - CANVAS_H/2 + player.h/2));
  }

  function update(dt = 1){
    if(gameOver) return;
    let moved = false;
    const old = { x: player.x, y: player.y };

    // calcular movimiento deseado (dx, dy)
    let dx = 0, dy = 0;
    if(keys['ArrowUp'] || keys['w']) { dy -= player.speed; moved = true; }
    if(keys['ArrowDown'] || keys['s']) { dy += player.speed; moved = true; }
    if(keys['ArrowLeft'] || keys['a']) { dx -= player.speed; moved = true; }
    if(keys['ArrowRight'] || keys['d']) { dx += player.speed; moved = true; }

    // Mover en X y resolver colisiones en X (evita problemas en esquinas)
    if(dx !== 0){
      player.x += dx * dt;
      player.x = Math.max(0, Math.min(worldW - player.w, player.x));
      for(const ob of obstacles){
        // solo interesa si hay solapamiento vertical
        if(player.y + player.h <= ob.y || player.y >= ob.y + ob.h) continue;
        if(aabbColl(player, ob)){
          if(dx > 0) { player.x = ob.x - player.w; collided = true; }
          else if(dx < 0) { player.x = ob.x + ob.w; collided = true; }
        }
      }
    }

    // Mover en Y y resolver colisiones en Y
    if(dy !== 0){
      player.y += dy * dt;
      player.y = Math.max(0, Math.min(worldH - player.h, player.y));
      for(const ob of obstacles){
        // solo interesa si hay solapamiento horizontal
        if(player.x + player.w <= ob.x || player.x >= ob.x + ob.w) continue;
        if(aabbColl(player, ob)){
          if(dy > 0) { player.y = ob.y - player.h; collided = true; }
          else if(dy < 0) { player.y = ob.y + ob.h; collided = true; }
        }
      }
    }

    if(moved){
      moves++;
      movesEl.textContent = moves;
    }
    timeEl.textContent = Math.floor((Date.now() - startTime)/1000);
    updateCamera();

    // comprobar recolecci√≥n del tesoro
    const playerCenter = { x: player.x + player.w/2, y: player.y + player.h/2 };
    const treasureCenter = { x: treasure.x + treasure.w/2, y: treasure.y + treasure.h/2 };
    const dist = Math.hypot(playerCenter.x - treasureCenter.x, playerCenter.y - treasureCenter.y);
    if(dist < (Math.max(player.w, player.h)/2 + Math.max(treasure.w, treasure.h)/2) ){
      treasuresFound++;
      foundEl.textContent = treasuresFound;
      // feedback: sonido y confeti
      playPickup();
      spawnConfetti(treasureCenter.x, treasureCenter.y, 60);
      if(level >= MAX_LEVEL){
        endGame(true);
      } else {
        level++;
        levelEl.textContent = level;
        spawnMapForLevel(level);
      }
    }

    // reproducir sonido de choque si hubo colisi√≥n al moverse
    if(typeof collided !== 'undefined' && collided){ playHit(); }
    collided = false;
    updateParticles(dt);
  }

  function drawFog(){
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.78)';
    ctx.fillRect(0,0,CANVAS_W,CANVAS_H);
    const gx = (player.x - camX) + player.w/2;
    const gy = (player.y - camY) + player.h/2;
    const grad = ctx.createRadialGradient(gx,gy,visibility*0.2, gx,gy,visibility);
    grad.addColorStop(0, 'rgba(0,0,0,0)');
    grad.addColorStop(1, 'rgba(0,0,0,0.95)');
    ctx.globalCompositeOperation = 'destination-out';
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(gx,gy,visibility,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
    ctx.globalCompositeOperation = 'source-over';
  }

  // minimapa - arriba a la izquierda
  const minimap = {
    w: 180,
    h: 140,
    padding: 12,
    bg: 'rgba(10,10,10,0.85)',
    border: 'rgba(200,200,200,0.12)'
  };

  function drawMinimap(){
    // seguridad
    if (worldW <= 0 || worldH <= 0) return;

    ctx.save();
    const mx = minimap.padding;
    const my = minimap.padding;

    // background + border
    ctx.globalAlpha = 1;
    ctx.fillStyle = minimap.bg;
    ctx.fillRect(mx - 2, my - 2, minimap.w + 4, minimap.h + 4);
    ctx.strokeStyle = minimap.border;
    ctx.lineWidth = 2;
    ctx.strokeRect(mx - 2, my - 2, minimap.w + 4, minimap.h + 4);

    // escala: ajustar m√≥n dins minimapa
    const scale = Math.min(minimap.w / worldW, minimap.h / worldH);

    // offset per centrar si m√≥n m√©s petit que la caixa
    const drawW = worldW * scale;
    const drawH = worldH * scale;
    const ox = mx + (minimap.w - drawW) / 2;
    const oy = my + (minimap.h - drawH) / 2;

    // dibuixar obstacles (sombrejat)
    ctx.fillStyle = '#333';
    for (const ob of obstacles) {
      ctx.fillRect(ox + ob.x * scale, oy + ob.y * scale, Math.max(1, ob.w * scale), Math.max(1, ob.h * scale));
    }

    // No mostrar el tresor al minimapa (intencionadament)

    // dibuixar jugador
    const px = ox + player.x * scale + player.w * scale / 2;
    const py = oy + player.y * scale + player.h * scale / 2;
    ctx.beginPath();
    ctx.fillStyle = player.color || '#5fb8ff';
    ctx.arc(px, py, Math.max(3, (Math.max(player.w, player.h) * scale) / 2), 0, Math.PI * 2);
    ctx.fill();

    // dibuixar rectangle de la vista actual (cam)
    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.lineWidth = 1.2;
    const viewX = ox + camX * scale;
    const viewY = oy + camY * scale;
    const viewW = CANVAS_W * scale;
    const viewH = CANVAS_H * scale;
    ctx.strokeRect(viewX, viewY, Math.max(2, viewW), Math.max(2, viewH));

    // label petit
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Minimapa', mx, my + minimap.h + 12);

    ctx.restore();
  }

  function draw(){
    ctx.clearRect(0,0,CANVAS_W,CANVAS_H);
    ctx.save();
    ctx.translate(-camX, -camY);
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(0,0,worldW,worldH);

    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1;
    const gridSize = 50;
    for(let gx = 0; gx < worldW; gx += gridSize){
      ctx.beginPath(); ctx.moveTo(gx,0); ctx.lineTo(gx,worldH); ctx.stroke();
    }
    for(let gy = 0; gy < worldH; gy += gridSize){
      ctx.beginPath(); ctx.moveTo(0,gy); ctx.lineTo(worldW,gy); ctx.stroke();
    }

    ctx.fillStyle = '#555';
    for(const ob of obstacles){
      ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
      ctx.strokeStyle = '#444';
      ctx.strokeRect(ob.x, ob.y, ob.w, ob.h);
    }

    ctx.fillStyle = treasure.color;
    ctx.fillRect(treasure.x, treasure.y, treasure.w, treasure.h);
    ctx.font = `${Math.max(10, treasure.w-6)}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#000';
    ctx.fillText('üíé', treasure.x + treasure.w/2, treasure.y + treasure.h/2);

    ctx.fillStyle = player.color;
    ctx.fillRect(player.x, player.y, player.w, player.h);
    ctx.fillStyle = '#fff';
    ctx.font = '16px sans-serif';
    ctx.fillText('üë§', player.x + player.w/2, player.y + player.h/2);

    // dibujar part√≠culas dentro del mundo (antes de restaurar la transform)
    drawParticles();

    ctx.restore();
    drawFog();

    // dibuixar minimapa per sobre de la boira
    drawMinimap();
  }

  function loop(now){
    if(!now) now = performance.now();
    if(!_lastFrameTime) _lastFrameTime = now;
    const rawDt = now - _lastFrameTime;
    _lastFrameTime = now;
    const dt = Math.min(40, rawDt) / 16.666; // normalize relative to 60fps
    update(dt);
    draw();
    if(!gameOver) requestAnimationFrame(loop);
  }

  function endGame(victory=false){
    gameOver = true;
    overlay.style.display = 'flex';
    if(victory){
      winText.textContent = 'üéâ ¬°Completaste todos los niveles!';
      const totalTime = Math.floor((Date.now() - startTime)/1000);
      winStats.textContent = `Niveles completados: ${treasuresFound} ¬∑ Movimientos: ${moves} ¬∑ Tiempo: ${totalTime}s`;
    } else {
      winText.textContent = 'Juego terminado';
      winStats.textContent = `Tesoros: ${treasuresFound} ¬∑ Movimientos: ${moves}`;
    }
  }

  window.addEventListener('keydown', e=>{
    keys[e.key] = true;
    if(e.code === 'Space' && gameOver) restart();
  });
  window.addEventListener('keyup', e=>{
    keys[e.key] = false;
  });

  restartBtn.addEventListener('click', restart);

  function restart(){
    level = 1;
    treasuresFound = 0;
    moves = 0;
    startTime = Date.now();
    gameOver = false;
    levelEl.textContent = level;
    foundEl.textContent = treasuresFound;
    movesEl.textContent = moves;
    timeEl.textContent = 0;
    overlay.style.display = 'none';
    spawnMapForLevel(1);
    requestAnimationFrame(loop);
  }

  levelEl.textContent = level;
  foundEl.textContent = treasuresFound;
  movesEl.textContent = moves;
  spawnMapForLevel(level);
  requestAnimationFrame(loop);
  </script>
</body>
</html>